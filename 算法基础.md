> yoyorm 的笔记

# 高精度 (不考虑负运算数)

## 加法

**实现原理:**

1. 确保 a 的长度 == b 的长度
2. 将 a 和 b 翻转保存
3. 创建结果字符串 res
4. 从个位开始，逐位相加，并记录进位
5. 循环结束后，如果进位 carry > 0，则将 carry 转为字符串并添加到结果字符串 res 的开头
6. 返回结果字符串 res

```cpp
string addNum(const string &a, const string &b)
{
    int maxsize = max(a.size(), b.size());
    string A = a;
    string B = b;
    //补全空位0
    while (A.size() < maxsize)
        A.insert(0, 1, '0');
    while (B.size() < maxsize)
        B.insert(0, 1, '0');
    //翻转
    reverse(A.begin(), A.end());
    reverse(B.begin(), B.end());

    string res;
    int carry = 0;
    for (int i = 0; i < maxsize; i++)
    {
        int temp = (A[i] - '0') + (B[i] - '0') + carry;
        carry = temp / 10;
        res.push_back(temp%10 + '0');
    }
    //进位处理
    while (carry)
    {
        res.push_back(carry % 10 + '0');
        carry /= 10;
    }
    reverse(res.begin(), res.end());
    return res;
}
```

## 减法

**实现原理:**

1. 确保 a 的长度 == b 的长度，不足就补全 0
2. 始终让大的数字减去小的数字，保存结果正负号即
3. 将 a 和 b 翻转保存
4. 从低位开始，逐位相减，并记录借位，不足补 10，借位+1
5. 循环结束后，处理前导 0 并且添加负号
6. 返回结果字符串 res

```cpp
string minusNum(const string &a, const string &b)
{
    int maxsize = max(a.size(), b.size());
    string A = a;
    string B = b;
    //补全空位0
    while (A.size() < maxsize)
        A.insert(0, 1, '0');
    while (B.size() < maxsize)
        B.insert(0, 1, '0');
    //判断正负号
    bool nagative = false;
    //确保大减小
    if (A < B)
    {
        swap(A, B);
        nagative = true;
    }
    reverse(A.begin(), A.end());
    reverse(B.begin(), B.end());

    string res;
    int carry = 0;
    for (int i = 0; i < A.size(); i++)
    {
        int temp =( A[i]-'0') - (B[i]-'0') - carry;
        if (temp < 0)
        {
            //不够就借位
            temp += 10;
            carry = 1;
        }
        else
            carry = 0;
        res.push_back(temp + '0');
    }

    reverse(res.begin(), res.end());
    //去掉前导0
    while (res.size() > 1 && res[0] == '0')
        res.erase(res.begin());
    //添加可能的负号
    if (nagative&&res!="0")
        res = '-' + res;
    return res;
}
```

## 乘法

### 逐位乘法

```cpp
string multiply(const string &a, const string &b)
{
    if (a == "0" || b == "0") return "0";
    // 特判 0
    string A = a, B = b;
    // 低位在前，方便进位
    reverse(A.begin(), A.end());
    reverse(B.begin(), B.end());

    int lenA = A.size(), lenB = B.size();
    // 乘积最多 lenA+lenB 位
    string res(lenA + lenB, '0');

    // 逐位相乘 遍历A为乘数，B为被乘数
    for (int i = 0; i < lenA; ++i)
    {
        int carry = 0;
        int digitA = A[i] - '0';
        for (int j = 0; j < lenB; ++j)
        //把A的每一位和B的每一位相乘，i也作为乘数位置的偏移量（同竖式乘法）
        {
            int temp = digitA * (B[j] - '0') + (res[i + j] - '0') + carry;
            res[i + j] = temp % 10 + '0';
            carry = temp / 10;
        }
        // 处理A每一位乘完后剩余的最高位的进位
        int k = lenB;
        while (carry)
        {
            int temp = (res[i + k] - '0') + carry;
            res[i + k] = temp % 10 + '0';
            carry = temp / 10;
            ++k;
        }
    }
    // 恢复高位在前
    reverse(res.begin(), res.end());
    // 去前导 0
    while (res.size() > 1 && res[0] == '0')
        res.erase(res.begin());
    return res;
    }
```

# 排序
## 插入排序
**实现原理**
```cpp
void insertSort(vector<int> &v)
{
    for (int i = 1; i < v.size(); i++)//从第二个元素开始遍历
    {
        int temp = v[i];//暂存当前元素
        int j = i - 1;//待插入位置索引
        while (j >= 0 && v[j] > temp)//通过索引向前查找，直到遇到小于等于自己的元素停下
        {
            v[j + 1] = v[j];//将大于自己的所有元素后移一位
            j--;
        }
        v[j+1] = temp;//把暂存元素插入到正确位置
    }
}
```