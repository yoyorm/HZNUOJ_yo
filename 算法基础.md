> yoyorm 的笔记

# 高精度 (不考虑负运算数)

## 加法

**实现原理:**

1. 确保 a 的长度 == b 的长度
2. 将 a 和 b 翻转保存
3. 创建结果字符串 res
4. 从个位开始，逐位相加，并记录进位
5. 循环结束后，如果进位 carry > 0，则将 carry 转为字符串并添加到结果字符串 res 的开头
6. 返回结果字符串 res

```cpp
string addNum(const string &a, const string &b)
{
    int maxsize = max(a.size(), b.size());
    string A = a;
    string B = b;
    //补全空位0
    while (A.size() < maxsize)
        A.insert(0, 1, '0');
    while (B.size() < maxsize)
        B.insert(0, 1, '0');
    //翻转
    reverse(A.begin(), A.end());
    reverse(B.begin(), B.end());

    string res;
    int carry = 0;
    for (int i = 0; i < maxsize; i++)
    {
        int temp = (A[i] - '0') + (B[i] - '0') + carry;
        carry = temp / 10;
        res.push_back(temp%10 + '0');
    }
    //进位处理
    while (carry)
    {
        res.push_back(carry % 10 + '0');
        carry /= 10;
    }
    reverse(res.begin(), res.end());
    return res;
}
```

## 减法

**实现原理:**

1. 确保 a 的长度 == b 的长度，不足就补全 0
2. 始终让大的数字减去小的数字，保存结果正负号即
3. 将 a 和 b 翻转保存
4. 从低位开始，逐位相减，并记录借位，不足补 10，借位+1
5. 循环结束后，处理前导 0 并且添加负号
6. 返回结果字符串 res

```cpp
string minusNum(const string &a, const string &b)
{
    int maxsize = max(a.size(), b.size());
    string A = a;
    string B = b;
    //补全空位0
    while (A.size() < maxsize)
        A.insert(0, 1, '0');
    while (B.size() < maxsize)
        B.insert(0, 1, '0');
    //判断正负号
    bool nagative = false;
    //确保大减小
    if (A < B)
    {
        swap(A, B);
        nagative = true;
    }
    reverse(A.begin(), A.end());
    reverse(B.begin(), B.end());

    string res;
    int carry = 0;
    for (int i = 0; i < A.size(); i++)
    {
        int temp =( A[i]-'0') - (B[i]-'0') - carry;
        if (temp < 0)
        {
            //不够就借位
            temp += 10;
            carry = 1;
        }
        else
            carry = 0;
        res.push_back(temp + '0');
    }

    reverse(res.begin(), res.end());
    //去掉前导0
    while (res.size() > 1 && res[0] == '0')
        res.erase(res.begin());
    //添加可能的负号
    if (nagative&&res!="0")
        res = '-' + res;
    return res;
}
```

## 乘法

### 逐位乘法

```cpp
string multiply(const string &a, const string &b)
{
    if (a == "0" || b == "0") return "0";
    // 特判 0
    string A = a, B = b;
    // 低位在前，方便进位
    reverse(A.begin(), A.end());
    reverse(B.begin(), B.end());

    int lenA = A.size(), lenB = B.size();
    // 乘积最多 lenA+lenB 位
    string res(lenA + lenB, '0');

    // 逐位相乘 遍历A为乘数，B为被乘数
    for (int i = 0; i < lenA; ++i)
    {
        int carry = 0;
        int digitA = A[i] - '0';
        for (int j = 0; j < lenB; ++j)
        //把A的每一位和B的每一位相乘，i也作为乘数位置的偏移量（同竖式乘法）
        {
            int temp = digitA * (B[j] - '0') + (res[i + j] - '0') + carry;
            res[i + j] = temp % 10 + '0';
            carry = temp / 10;
        }
        // 处理A每一位乘完后剩余的最高位的进位
        int k = lenB;
        while (carry)
        {
            int temp = (res[i + k] - '0') + carry;
            res[i + k] = temp % 10 + '0';
            carry = temp / 10;
            ++k;
        }
    }
    // 恢复高位在前
    reverse(res.begin(), res.end());
    // 去前导 0
    while (res.size() > 1 && res[0] == '0')
        res.erase(res.begin());
    return res;
    }
```

# 排序
## 插入排序
**实现原理**
```cpp
void insertSort(vector<int> &v)
{
    for (int i = 1; i < v.size(); i++)//从第二个元素开始遍历
    {
        int temp = v[i];//暂存当前元素
        int j = i - 1;//待插入位置索引
        while (j >= 0 && v[j] > temp)//通过索引向前查找，直到遇到小于等于自己的元素停下
        {
            v[j + 1] = v[j];//将大于自己的所有元素后移一位
            j--;
        }
        v[j+1] = temp;//把暂存元素插入到正确位置
    }
}
```
## 希尔排序
**实现原理**
希尔排序就是多次的插入排序：选择样本量从粗到细
通过gap控制样本之间的间隔，样本间隔逐渐缩小，直到为1（相当于插入排序）
但是由于先移动最远处的元素，所以减少了其他不必要的移动次数，减少了移动总量
随着gap不断变小，此时数据已经逼近有序，所以移动的量变少。
最优的时间复杂度未nlogn，最坏未 nlog2n
```cpp
void shellSort(vector<int> &v, int n)
{
    for (int gap = n / 2; gap > 0; gap /= 2)//样本间隔
    {
        for (int i = gap; i < v.size(); i++)//内部与插入排序完全一样，间隔为gap
        {
            int temp = v[i];
            int j = i - gap;
            while (j >= 0 && v[j] > temp)
            {
                v[j + gap] = v[j];
                j-=gap;
            }
            v[j + gap] = temp;
        }
    }
}
```
## 选择排序
**实现原理**
每次找到后续元素中最小的元素，交换到当前位置
```cpp
void selectSort(vector<int> &v)
{

    for (int i = 0; i < v.size(); i++)
    {
        int min = i;//最小元素索引
        for (int j = i+1; j < v.size(); j++)//找到最小元素索引
        {
            if (v[j] < v[min])
            {
                min = j;
            }
        }
        swap(v[i], v[min]);//交换
    }
}
```
## 归并排序
**实现原理**
归并排序是分治法，将数组分为左右两个子数组，对左右两个子数组进行排序，然后合并两个有序的子数组
```cpp
void merge(vector<int> &arr, int left, int mid, int right)
{
    int n1 = mid - left + 1; // 左段长度
    int n2 = right - mid;    // 右段长度
    vector<int> L(arr.begin() + left, arr.begin() + left + n1);
    vector<int> R(arr.begin() + mid + 1, arr.begin() + mid + 1 + n2);

    int i = 0, j = 0, k = left; // k 写回原数组
    while (i < n1 && j < n2)
    {
        if (L[i] <= R[j])
            arr[k++] = L[i++]; // 稳定性：<= 取左边
        else
            arr[k++] = R[j++];
    }
    while (i < n1)
        arr[k++] = L[i++];
    while (j < n2)
        arr[k++] = R[j++];
}
void mergeSort(vector<int> &arr, int left, int right)
{
    if (left >= right)
        return;                          // 0 或 1 个元素，天然有序
    int mid = left + (right - left) / 2; // 防溢出写法
    mergeSort(arr, left, mid);           // 先排左边
    mergeSort(arr, mid + 1, right);      // 再排右边
    merge(arr, left, mid, right);        // 把两段排序写回原数组
}
```
## 快速排序
**实现原理**
快速排序是分治法，通过一个基准值将数组分为左右两个子数组，然后对左右两个子数组进行排序
排序过程中：选择最右侧元素的值为基准值，然后从左向右遍历，遇到小于基准的就和基准位置交换，同时基准位置++，遇到更大的元素不需移动基准值，继续遍历即可
```cpp
int partition(vector<int>& a, int l, int r) {
    int pivot = a[r];
    int i = l;
    for (int j = l; j < r; ++j)//从左开始与pivot比较
        if (a[j] < pivot) 
            swap(a[i++], a[j]);//小于就交换位置并且基准位置右移，大于基准位置不变
    swap(a[i], a[r]);//最后把基准值放在基准的位置上
    return i;
}

void quickSort(vector<int>& a, int l, int r) {
    if (l < r) {
        int p = partition(a, l, r);//分一次得到基准位置
        quickSort(a, l, p - 1);//左右再排序
        quickSort(a, p + 1, r);
    }
}
```