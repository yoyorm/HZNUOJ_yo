>yoyorm的笔记

# 高精度 (不考虑负运算数)
## 加法
**实现原理:**
1. 确保a的长度 == b的长度
2. 将a和b翻转保存
3. 创建结果字符串res
4. 从个位开始，逐位相加，并记录进位
5. 循环结束后，如果进位carry > 0，则将carry转为字符串并添加到结果字符串res的开头
6. 返回结果字符串res

```cpp
string addNum(const string &a, const string &b)
{
    int maxsize = max(a.size(), b.size());
    string A = a;
    string B = b;
    //补全空位0
    while (A.size() < maxsize)
        A.insert(0, 1, '0');
    while (B.size() < maxsize)
        B.insert(0, 1, '0');
    //翻转
    reverse(A.begin(), A.end());
    reverse(B.begin(), B.end());

    string res;
    int carry = 0;
    for (int i = 0; i < maxsize; i++)
    {
        int temp = (A[i] - '0') + (B[i] - '0') + carry;
        carry = temp / 10;
        res.push_back(temp%10 + '0');
    }
    //进位处理
    while (carry)
    {
        res.push_back(carry % 10 + '0');
        carry /= 10;
    }
    reverse(res.begin(), res.end());
    return res;
}  
```

## 减法
**实现原理:**  
1. 确保a的长度 == b的长度，不足就补全0
2. 始终让大的数字减去小的数字，保存结果正负号即 
3. 将a和b翻转保存
4. 从低位开始，逐位相减，并记录借位，不足补10，借位+1
5. 循环结束后，处理前导0并且添加负号
6. 返回结果字符串res

```cpp
string minusNum(const string &a, const string &b)
{
    int maxsize = max(a.size(), b.size());
    string A = a;
    string B = b;
    //补全空位0
    while (A.size() < maxsize)
        A.insert(0, 1, '0');
    while (B.size() < maxsize)
        B.insert(0, 1, '0');
    //判断正负号
    bool nagative = false;
    //确保大减小
    if (A < B)
    {
        swap(A, B);
        nagative = true;
    }
    reverse(A.begin(), A.end());
    reverse(B.begin(), B.end());

    string res;
    int carry = 0;
    for (int i = 0; i < A.size(); i++)
    {
        int temp = A[i] - B[i] - carry;
        if (temp < 0)
        {
            //不够就借位
            temp += 10;
            carry = 1;
        }
        else
            carry = 0;
        res.push_back(temp + '0');
    }

    reverse(res.begin(), res.end());
    //去掉前导0
    while (res.size() > 1 && res[0] == '0')
        res.erase(res.begin());
    //添加可能的负号
    if (nagative&&res!="0")
        res = '-' + res;
    return res;
}
```



