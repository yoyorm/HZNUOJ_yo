# 图的遍历

## BFS

广度优先搜索，从某一个节点开始，按照节点的宽度进行遍历。
即先访问节点的相邻节点，再依次访问相邻节点的相邻节点，依次类推，直到所有节点都被访问

```cpp
//例如 遍历的类型为 无向图
//graph = [[1,2], [0,3], [0,3], [1,2]] （解释：0节点可以到1和2....）
void BFS(int start, const vector<vector<int>>& graph)
{
    vector<bool> visited(graph.size(), false);      // 创建访问状态数组
    queue<int> q;                                   // 创建依次访问队列

    visited[start] = true;                          // 标记起始节点为已访问
    q.push(start);                                  // 将起始节点加入访问队列

    while (!q.empty()) {
        int node = q.front();                       // 获取队列的头节点
        //cout << node << " ";                      // 处理当前节点

        // 将所有未访问的邻居加入队列
        for (int neighbor : graph[node])            // 通过队列的首个节点，遍历当其邻居
        {
            if (!visited[neighbor])
            {
                visited[neighbor] = true;           // 标记邻居为已访问
                q.push(neighbor);                   // 将邻居加入未来要访问的队列
            }
        }

        q.pop();                                    // 删除已访问的节点
    }
}
//输出：[0, 1, 3, 2]
```

## DFS

深度优先搜索，一直走一条路直到死路再回头
递归实现：
通过对应大小的数组存储访问状态
如果节点没有访问，则访问该节点，并标记为已访问，一直到结束

```cpp
//例如 遍历的类型为 无向图
//graph = [[1,2], [0,3], [0,3], [1,2]] （解释：0节点可以到1和2....）
void DFS(int node, vector<bool>& visited, const vector<vector<int>>& graph)
{
    visited[node] = true;
    //cout << node << " ";                           // 处理当前节点的内容

    // 遍历所有邻居
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            DFS(neighbor, visited, graph);          //递归继续访问内部节点
        }
    }
}
//输出：[0, 1, 2, 3]
```

# 最短路径

## Dijkstra
从根出发，记录可以到达的每一个节点，更新出发点到目标的最短距离；
从可到达的节点选择一个最短距离节点前进；
重复：记录分支节点距离累加当前节点的最短距离，选择一个最短距离节点前往的过程。

```cpp
void Dijkstra(const vector<vector<int>> &map, vector<int> &mindis, int start, int nodeNum) //mindis存储出发点到各个节点的最小路径，初始化为无穷大
{
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> que;//创建小顶端优先队列，用来搜寻最小距离的路径
    mindis[start] = 0;      //初始化出发点，到自己距离为0
    que.push({0, start});       //将起始点加入队列
    while (!que.empty())
    {
        int dis = que.top().first;
        int node = que.top().second;

        que.pop();
        if (dis > mindis[node])    //当遇到节点距离已经大于当前最短距离，说明是冗余路径，直接跳过
        {
            continue;
        }

        for (int i = 0; i < nodeNum; i++) //遍历当前节点的邻居
        {
            if (map[node][i] == INT_MAX)    //如果邻居不可达，则跳过
            {
                continue;
            }
            if (map[node][i] < mindis[i] - mindis[node])    //如果当前节点到邻居的距离，累加上出发点到邻居的距离，小于当前最短距离，则更新最短距离
            {

                mindis[i] = map[node][i] + mindis[node];
                que.push({mindis[i], i});//把这个新的可用节点加入队列
            }
        }
    }
}
```
