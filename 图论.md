# 图的遍历
## BFS

广度优先搜索，从某一个节点开始，按照节点的宽度进行遍历。
即先访问节点的相邻节点，再依次访问相邻节点的相邻节点，依次类推，直到所有节点都被访问

```cpp
//例如 遍历的类型为 无向图
//graph = [[1,2], [0,3], [0,3], [1,2]] （解释：0节点可以到1和2....）
void BFS(int start, const vector<vector<int>>& graph)
{
    vector<bool> visited(graph.size(), false);      // 创建访问状态数组
    queue<int> q;                                   // 创建依次访问队列

    visited[start] = true;                          // 标记起始节点为已访问
    q.push(start);                                  // 将起始节点加入访问队列

    while (!q.empty()) {
        int node = q.front();                       // 获取队列的头节点
        //cout << node << " ";                      // 处理当前节点

        // 将所有未访问的邻居加入队列
        for (int neighbor : graph[node])            // 通过队列的首个节点，遍历当其邻居
        {
            if (!visited[neighbor])
            {
                visited[neighbor] = true;           // 标记邻居为已访问
                q.push(neighbor);                   // 将邻居加入未来要访问的队列
            }
        }

        q.pop();                                    // 删除已访问的节点
    }
}
//输出：[0, 1, 3, 2]
```

## DFS

深度优先搜索，一直走一条路直到死路再回头
递归实现：
通过对应大小的数组存储访问状态
如果节点没有访问，则访问该节点，并标记为已访问，一直到结束

```cpp
//例如 遍历的类型为 无向图
//graph = [[1,2], [0,3], [0,3], [1,2]] （解释：0节点可以到1和2....）
void DFS(int node, vector<bool>& visited, const vector<vector<int>>& graph)
{
    visited[node] = true;
    //cout << node << " ";                           // 处理当前节点的内容

    // 遍历所有邻居
    for (int neighbor : graph[node]) {
        if (!visited[neighbor]) {
            DFS(neighbor, visited, graph);          //递归继续访问内部节点
        }
    }
}
//输出：[0, 1, 2, 3]
```
